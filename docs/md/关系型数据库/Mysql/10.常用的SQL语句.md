# 常用的SQL语句

## 查看多表的行数

以A、B、C 三张表为例

```sql
SELECT sum(A) A,sum(B) B,sum(C) C FROM (
  SELECT count(0) A,0 B,0 C  from A
  UNION ALL
  SELECT 0 A,count(0) B,0 C  from B
  UNION ALL
  SELECT 0 A,0 B,count(0) C  from C
) t;
```

## on duplicate key update

* 不建议使用  
    * MySQL私有语法，非SQL92标准语法，如果需要迁移数据层产品会造成麻烦，需要付出额外时间成本去改写代码。  
    * MySQL自身通过唯一键的查找进行数据排重，并决定是否进行INSERT或者UPDATE，业务逻辑分散在应用逻辑层和数据层，对项目维护留下隐患。
    * 在MylSAM存储引擎下使用的是表锁，性能不好。
    * 在InnoDB并发事务情况下可能会出现锁表/死锁问题。
    * 使用场景有限，不能用于多唯一索引的情况下。

## 批量新增

可以使用 MySQL 的 INSERT INTO 语句批量插入多条数据，语法如下：
```sql
INSERT INTO table_name (column1, column2, column3, ...)
VALUES
(value1, value2, value3, ...),
(value1, value2, value3, ...),
(value1, value2, value3, ...),
...
```

其中，table_name 是要插入数据的表名，column1, column2, column3 是表的字段名，value1, value2, value3 是要插入的值。可以在 VALUES 后面添加多个用逗号隔开的值，以插入多条数据。

例如，如果要向 student 表中插入三条数据，可以使用如下的 SQL 语句：
```sql
INSERT INTO student (name, age, gender)
VALUES
('张三', 18, '男'),
('李四', 19, '女'),
('王五', 20, '男');
```

## 批量更新

可以使用 MySQL 的 UPDATE 语句批量更新多条数据，语法如下：
```sql
update `test_table`
set 
    test_column_alpha = CASE id 
        WHEN xxx THEN xxx
		WHEN xxx THEN xxx
        ... （省略其它的WHEN）
    END, 
    test_column_beta = CASE id 
        WHEN xxx THEN xxx
		WHEN xxx THEN xxx
        ... （省略其它的WHEN）
        ELSE test_column_beta 
    END
WHERE id IN (
    xxx,
	xxx, 
    ... （省略其它的id）
)
```

## select XXX for update语句的作用

select for update语句用于在查询某些数据时对其进行加锁，以避免其他事务同时对这些数据进行修改。在使用此语句时，查询的数据将被锁定，直到事务提交或回滚为止。这可以确保在更新/修改数据时，其他事务不会同时对其进行修改，从而避免了数据不一致的情况。该语句通常用于并发环境中，以确保数据的准确性和一致性。

## MySQL 5.7版本InnoDB对COUNT(*)的优化

InnoDB对COUNT(*)做了多种优化，包括：
* 使用聚集索引：如果表有聚集索引，InnoDB可以快速地遍历聚集索引来获取行数。
* 维护表元数据：InnoDB维护了每个表的元数据，包括行数和页数。当执行COUNT(*)时，InnoDB可以直接返回这些元数据，从而避免扫描整个表。
* 利用统计信息：InnoDB会收集表的统计信息，包括行数和页数等信息。当执行COUNT(*)时，InnoDB可以使用这些统计信息来估算行数，从而避免扫描整个表。
* 预估行数：InnoDB会预估查询结果的行数，并根据预估的行数来选择执行计划。当执行COUNT(*)时，InnoDB会使用这些预估行数来优化查询。

## exist用法

有三个MySQL表，A、B、C表有字段user_name，怎么筛选出不在B、C表中但A表中存在的user_name
可以使用NOT EXISTS子查询来实现：

```sql
SELECT user_name FROM A
WHERE NOT EXISTS (
  SELECT 1 FROM B
  WHERE B.user_name = A.user_name
) AND NOT EXISTS (
  SELECT 1 FROM C
  WHERE C.user_name = A.user_name
)
```

该查询将返回在A表中存在，但是在B表和C表中不存在的user_name。
