# 数据库设计规范

## 概述

数据库是公司信息的核心，其应用水平的高低直接影响到项目业务的发展水平。数据库设计的好坏决定了系统的性能、容量、可扩展性、可维护性等重要指标。一个好的数据库设计不仅可以保障业务的高速发展，而且可以有效节约服务器、网络等资源。数据库设计规范正是为保障线上系统能有良好的应用环境而提出的一个规则手册，适用于MySQL等数据库管理系统，主要规范对象是在MySQL上应用开发的程序员，DBA以及SQL优化相关人员。

## 命名规范

指数据库中表（TABLE），字段（COLUMN），索引（INDEX）等的命名规范，主要是针对在开发过程中对数据库中表、字段、索引等命名的一些规则。

> 基本命名原则

1. 命名统一采用26个小写英文字母和0－9这十个自然数，加上下划线_组成，共37个字符。不能出现其他字符（注释除外）。
   * 不规范示例：USERINFO、Post@HZ  
   * 规范示例：userinfo、posthz、customer、customer_order  
2. 名称长度不超过30个字符，要求使用能准确表达对象功能的单数单词或单词缩写。  
3. 单个数据库中如果含系统多个模块对象，名称中需要加模块前缀。  
   * 示例：yx_user、yx_group、music_userrecommend

> 表命名
1. 实体表使用小写英文单词或单词组合，如userinfo、address。关系表由‘实体表_实体表’组成，如userinfo_address。
2. 临时表的名称，以tmp开头，以创建日期结尾，如tmp_userexpired_20140101。

> 字段命名
1. 字段的名称中如果包含多个单词，则由下划线分隔，如last_name、dest_address。
2. 关联表间的关联字段应同名或以表面_字段名命名，如role表引用了user表的id字段则role表中关联字段为user_id即 user.id=role.user_id。

> 索引命名
1. 除了主键外，所有索引必须定义索引名，格式为"索引前缀+字段名列表"。
2. 索引前缀：除主键外的唯一性索引，使用"uk_"开头（unique key，唯一键），非唯一性索引，使用“idx_”开头。
3. 字段名列表：单个字段尽量使用字段全名；多个字段名之间用下划线分隔，多个字段则尽量使用名字缩写。例如，(userid,parentid)上的非唯一性索引，可以命名为idx_uid_pid；userid上的唯一索引命名为uk_userid。

## 设计规范

主要是针对如何设计高效、可维护的数据库模式(表)的一些约定及建议。

> 字段的设计
1. 字段类型选择，尽量选择能满足应用要求的最小数据类型，关联表间字段类型要求一致。例如，is_deleted字段值只有true/false值，可以考虑使用tinyint类型，无需使用int或varchar类型。
2. 字段长度选择，避免定义过长的字段长度。合适的字段及字段长度不仅可以有效减少内存磁盘网络等方面开销，还可以加速ddl/join等执行速度，如主机名可以定义为varchar(64)，不要随便定义为varchar(1000)。
3. 尽量使用整型代替字符型。整形在字段长度、索引大小等方面开销更小效率更高，如ip字段、邮编字段等。
4. 非空及默认值定义，建议字段都设为非空，使用如-1、0、空字符串等常量代替NULL值。
5. 字符集选择，选择满足应用要求的字符集与字符比较集，如无特殊要求，则统一使用表级别字符集，否则需要在字段级别单独定义。
6. 禁止使用enum、set、boolean等数据类型，统一使用tinyint代替，金融类数据禁止使用float、double类型，统一只用decimal。
7. 注释，每个字段必须以COMMENT语句给出字段的作用、必要的取值范围等。

> 索引的设计
1. 选择在where子句中出现，且选择性和过滤性高的字段创建索引，过滤性少的无需创建。
2. 在经常组合的过滤字段上做复合索引，选择性高的字段放在前面。
3. 较长字符类型字段考虑使用前缀索引，如字段定义：user_name varchar(255) 字段前8个字符即可非常准确过滤，此时可以考虑建立索引idx_user_name(8)。
4. 在需要order by/distinct/group by 等字段上建立合适索引。
5. 在执行频率、并发非常高的情况下考虑建立覆盖索引，如下面语句并发非常高(建立idx_uid_pid_mid(uid,is_valid,pid,order_id)索引) ：  
   select uid,pid,order_id from user where uid=234 and is_valid=1;
   
> 约束的设计

1. 主键约束：每张表需要有一个主键，统一用id bigint unsigned自增字段。
2. 唯一约束：每张关键业务表需要有一个唯一键，代表业务规则。
3. 不在数据库中定义外键，由应用保证，避免带来锁问题。
4. 使用整型来实现check约束，如 性别字段使用tinyint，0表示男，1表示女。

> 表其他规范
1. 表中必须包含表示记录修改时间字段db_update_time，同时建议加上表示记录插入时间的字段db_create_time。
2. 如果表需要经常更新且更新的字段占比很少，将需要频繁更新的字段拆分到单独表。
3. 经常访问的大字段（如blob,text）等需要单独放到一张表中，避免降低SQL效率，图片、电影等大文件数据禁止存数据库。
4. 表的字符集统一使用utf8或utf8mb4(移动产品)，比较字符集使用utf8_general_ci，如有特殊需求，在字段中单独定义。
5. 必须包含表功能的注释在建表语句中。

> 建表示例
```sql
CREATE TABLE user (
  id int unsigned NOT NULL AUTO_INCREMENT,
  name varchar(64) not null default '' comment '用户名',
  password 	varchar(128) NOT NULL default '' comment '加密后字符串',
  email varchar(64) not null default '' comment '邮箱',
  age tinyint unsigned  comment '年龄',
  sex tinyint comment '0:男，1:女',
  mobile bigint unsigned not null comment '用户手机号码',
  birthday date comment '生日日期',
  face_url varchar(255) not null default '' comment '头像url',
  address varchar(255) not null default '' comment '地址',
  is_active tinyint not null default 1 comment '是否激活,1：是 0:不是',
  db_create_time timestamp NOT NULL DEFAULT '2000-01-01 00:00:00',
  db_update_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  unique key uk_name(name),
  key idx_mobile(mobile)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 comment '用户信息';

```

## SQL编写规范

SQL编写规范，是针对常用SQL语句给出一些高效编写的建议。

> DML事务相关规则

DML即data manipulation language，它是SELECT、UPDATE、INSERT、DELETE，这四条命令是用来对数据库里的数据进行操作的语言。

* select/insert语句必须指定出具体的字段名，select for update/delete/update语句必须要有过滤字段，且过滤字段上需要有区分度高的索引。
  * 说明： Innodb存储引擎根据索引加锁，select for update/delete/update的过滤字段上没有索引，则SQL将锁整张表,有区分度不高的索引将锁大部分数据。
* 使用短小事务，不使用显示加锁如select for update/lock in share mode等。
* 大量数据需要更改时（更新记录超过10万条），操作时需要使用批量提交，并且避免业务高峰期操作。

> 查询语句-过滤字段

* 不在where子句中对索引字段施加函数，这样将导致SQL无法正确利用索引。
    * 错误：select id,name from tab where unix_timestamp(db_create_time)= 13883324。
    * 正确：select id,name from tab where db_create_time = from_unixtime(13883324)。
* 模糊查询like：在业务允许情况下，尽量使用右模糊查询。
    * 说明：col_name like 'abc%' 可以使用索引 而col_name like '%abc'则不可以。
* 严格要求使用正确类型的变量，杜绝隐式类型转换,表Join时join字段必须确保类型一致。
    * int_code为int类型，错误写法：int_code='1234' 正确写法：int_code=1234。
    * str_code为char类型，表join时 错误写法：a.str_code=b.int_code，正确写法：cast(a.str_code as signed)=b.int_code。

> 查询优化建议

* 降低SQL复杂度，将需要多表关联的复杂查询拆分为多个简单查询。
* 严禁使用select *，明确写出查询的具体字段
    * select * 可能消耗更多的cpu、内存、网络等资源。
    * 可能导致覆盖索引无法使用。
    * 可能导致order by语句无法使用最优的排序算法
* 尽量避免使用子查询，可以改为left join或拆为多条sql。
    * 执行子查询时，MySQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。
* 不需要去重情况下使用 union all 而非 union，因为union需要额外的去重操作。
* 不在数据库端进行复杂计算（如浮点运算、时间复杂度计算等），将计算等任务交给服务端完成。
* 正确使用索引进行order by /group by /distinct，避免filesort use tmp table等情况。
* 没必要的时候不要做外连接，内连接效率比外连接高。
* or条件若不能正确的走索引 可以考虑使用union 或in，通常同一个字段的or操作可以改为in，不同字段or操作改为union
    * 使用in，如select id,uid,cid from  tab where uid = 1 or uid= 100 or uid=10; 改为：select id,uid,cid from tab where uid in (1,100,100);
    * 使用union，如select id,uid,cid from tab  where  uid=100 or cid=500改为：  select id,uid,cid from tab  where  uid=100 union  select id,uid,cid from tab  where  cid=500;
* 避免检索大字段。
* 使用预编译（prepare），减少解析，防止注入。
* 计数统一使用count(*)，而不是count(1)或count(pk)也不是count(col_name)。
    * 当col_name 为空时count(col_name) 结果与count(*) 不一致，这里我们统一规定使用count(*) 而不是count(1) 或count(pk）。
    * 在5.7版本中，InnoDB实现了新的handler的records接口函数，当需要表上的精确记录个数时，会直接调用该函数进行计算，总是使用聚集索引来进行计算行数。
* in字句中不超过1000个常量。
* 禁止SQL中笛卡尔集操作，即表Join时不指定关联字段。
* 禁止查询结果非常大，建议使用Limit分段取结果。