# 测试算法性能

如果数据规模太小，在现代计算机本就计算能力强的情况下，比如想要估算算法O(n)时间复杂度的性能，需要十万甚至百万的数据才能解决。
因此需要解决生成大量测试数据的问题。

这里可以使用数组生成器来解决。

数组生成器
```java
/**
 * 数组生成器
 * @author yinaicheng
 */
public class ArrayGenerator {

    public ArrayGenerator(){
    }

    /**
     * 生成排序数组
     */
    public static Integer[] generateOrderedArray(int n){
        Integer[] arr=new Integer[n];
        for(int i=0;i<n;i++){
            arr[i]=i;
        }
        return arr;
    }

}
```

学生类
```java
import java.util.Objects;
/**
 * 学生类
 */
public class Student{

    /**
     * 学生姓名
     */
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     * equals根据需求重写，根据自己需要如何判断学生相等，这里只要学生姓名名字相同就认定是同一个人
     */
    @Override
    public boolean equals(Object o) {
        /*比较内存引用地址*/
        if (this == o){
            return true;
        }
        /*判空*/
        if (o == null){
            return false;
        }
        /*判断是不是同一个类*/
        if(getClass() != o.getClass()){
            return false;
        }
        Student student = (Student) o;
        return Objects.equals(this.name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

}
```

评估算法性能测试用例
```java
import org.junit.Test;
import java.text.MessageFormat;
/**
 * @author yinaicheng
 */
public class LinearSearch {

    /**
     * 如果不想要外部用户去new，可以私有private
     */
    public LinearSearch(){};

    /**
     * 这个方法用到类型E，具体是什么，不指定
     * @param data 查找的数组
     * @param target 要查找的值
     * @return 查找到的值的位置
     */
    public static <E> int search(E[] data,E target){
        for(int i=0;i<data.length;i++){
            /*==判断的是引用相等，equals判断的是值相等，如果是对象，要重写equals方法*/
            if(data[i].equals(target)){
                return i;
            }
        }
        return -1;
    }

    @Test
    public void testLargeMonuntDataSearchPerformance(){
        /*测试多个数据规模*/
        int[] dataSize={100000,1000000,10000000};
        for(int n:dataSize){
            Integer[] data= ArrayGenerator.generateOrderedArray(n);
        /*
        System.currentTimeMillis()返回以毫秒为单位的当前时间。注意，当返回值的时间单位是毫秒时，值的粒度取决于底层操作系统，并且粒度可能更大。例如，许多操作系统以几十毫秒为单位测量时间
        System.nanoTime()返回最准确的可用系统计时器的当前值，以毫微秒为单位
         */
            long startTime=System.nanoTime();
            /*要么提升数据规模，要么增加循环次数，看累加时间是多少，相对而言提升数据规模，得到的时间会稳定许多*/
            for(int k=0;k<100;k++){
                /*查找最后一个值，最差情况*/
                LinearSearch.search(data,n);
            }
            long endTime=System.nanoTime();
            /*为了获取浮点数，除以的就是浮点数*/
            double time=(endTime-startTime)/1000000000.0;
            System.out.println(MessageFormat.format("n={0}, 100 runs : {1} s",String.valueOf(n),String.valueOf(time)));
        }
    }

}
```

执行结果
```log
n=100000, 100 runs : 0.0160564 s
n=1000000, 100 runs : 0.1849822 s
n=10000000, 100 runs : 1.5940136 s
```

可以看出，以线性查找法（O(n)时间复杂度）为例，不同的数据量对应的执行时间是不一样的，且算法执行时间差不多正好与数据规模成正比。