# 选择排序法

排序算法的目的是让数据有序，每种排序算法都包含着算法设计思想，选择排序法可以被认为是最简单的排序算法。

选择排序法的算法设计思想：每次从还没处理的元素集合里选择最小的元素
1. 先把最小的元素拿出来
2. 从剩下的元素集合中，把最小的元素拿出来
3. 再从剩下的元素集合中，把最小的元素拿出来
4. ...

## 选择排序法循环不变量

arr[0...n]的数组，arr[0...i)已排序，arr[i...n]未排序，arr[i...n]的最小值要放到arr[i]的位置。

## 选择排序法动图

![](./photo/selection_sort_gif.gif)

## 实现选择排序法
```java
/**
 * 选择排序算法
 * @author: yinaicheng
 * @date: 2022/2/4 0:25
 */
public class SelectionSort {

    private SelectionSort(){}

    /**
     * 索引i初始索引0的位置，表示想寻找排序之后数组中的第0个位置应该是哪个元素，也就是最小数组元素
     * 索引j从索引i开始到n的元素遍历，找到最小的那个元素，minIndex记录排序前最小元素所在位置
     */
    public static void sort(int[] arr){
        /*遍历要选择排序的数组*/
        /*维持循环不变量：arr[0...i)是有序的，arr[i...n)是无序的*/
        for(int i=0;i<arr.length;i++){
            /*默认arr[i...n)最小值的索引是i*/
            int minIndex=i;
            /*遍历arr[i...n)数组，找到最小值*/
            for(int j=i;j<arr.length;j++){
                if(arr[j]<arr[minIndex]){
                    minIndex=j;
                }
            }
            /*经过遍历，找到最小值之后，数组值交换*/
            swap(arr,i,minIndex);
        }
    }

    /**
     * 数组值交换
     */
    private static void swap(int[] arr,int i,int j){
        /*通过中间值交换*/
        int t=arr[i];
        arr[i]=arr[j];
        arr[j]=t;
    }

    public static void main(String[] args) {
        int[] arr={1,4,2,3,6,5};
        SelectionSort.sort(arr);
        for(int e:arr){
            System.out.print(e+" ");
        }
        System.out.println();
    }

}
```

## 使用带约束的泛型实现选择排序法

注意要点：
* 排序泛型必须实现Comparable接口，保证排序元素可比较
* 泛型应该是个类，不应该是基本数据类型

```java
/**
 * 选择排序算法（使用带约束的泛型）
 * @author: yinaicheng
 * @date: 2022/2/4 0:25
 */
public class SelectionSort{

    private SelectionSort(){}

    /**
     * 需要让E这种类型实现Comparable这个接口（泛型约束）
     */
    public static <E extends Comparable<E>> void sort(E[] arr){
        /*遍历要选择排序的数组*/
        /*维持循环不变量：arr[0...i)是有序的，arr[i...n)是无序的*/
        for(int i=0;i<arr.length;i++){
            /*默认arr[i...n)最小值的索引是i*/
            int minIndex=i;
            /*遍历arr[i...n)数组，找到最小值*/
            for(int j=i;j<arr.length;j++){
                if(arr[j].compareTo(arr[minIndex])<0){
                    minIndex=j;
                }
            }
            /*经过遍历，找到最小值之后，数组值交换*/
            swap(arr,i,minIndex);
        }
    }

    /**
     * 数组值交换
     */
    private static <E> void swap(E[] arr,int i,int j){
        /*通过中间值交换*/
        E t=arr[i];
        arr[i]=arr[j];
        arr[j]=t;
    }

    public static void main(String[] args) {
        Integer[] arr={1,4,2,3,6,5};
        SelectionSort.sort(arr);
        for(int e:arr){
            System.out.print(e+" ");
        }
        System.out.println();
    }

}
```

## 对象实现Comparable接口

上面使用了带约束的泛型实现了选择排序法，泛型示例使用的是Integer对象，Integer是实现了Comparable这个接口。

假定student这个对象，也要保证可排序的话，必须也要实现Comparable这个接口，实现该接口必须实现Compare to这个方法。

两个student对象，如何比较大小，如何确定是同一个对象，是由类的设计者来设定的。

Student类
```java
import javax.validation.constraints.NotNull;
import java.util.Objects;

/**
 * @author 学生
 */
public class Student implements Comparable<Student>{

    private String name;

    /**
     * 学生的某次考试成绩
     */
    private int score;



    public Student(String name) {
        this.name = name;
    }

    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     * equals根据需求重写，设计者根据自己需要如何判断学生相等
     * @param o
     * @return
     */
    @Override
    public boolean equals(Object o) {
        /*比较地址*/
        if (this == o){
            return true;
        }
        /*判空*/
        if (o == null){
            return false;
        }
        /*判断是不是同一个类*/
        if(getClass() != o.getClass()){
            return false;
        }
        Student student = (Student) o;
        return Objects.equals(this.name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

    /**
     * 当前的这个类和传来的这个类进行比较，如果这个类比传来的这个类小的话，就负值
     */
    @Override
    public int compareTo(@NotNull Student another) {
        return this.score-another.score;
    }

    @Override
    public String toString() {
        return String.format("Student(name: %s, score: %d)",name,score);
    }

}
```

选择排序算法，带约束的泛型实现Comparable接口
```java
/**
 * 选择排序算法
 * @author: yinaicheng
 * @date: 2022/2/4 0:25
 */
public class SelectionSort{

    private SelectionSort(){}

    /**
     * 需要让E这种类型实现Comparable这个接口（泛型约束）
     */
    public static <E extends Comparable<E>> void sort(E[] arr){
        /*遍历要选择排序的数组*/
        /*维持循环不变量：arr[0...i)是有序的，arr[i...n)是无序的*/
        for(int i=0;i<arr.length;i++){
            /*默认arr[i...n)最小值的索引是i*/
            int minIndex=i;
            /*遍历arr[i...n)数组，找到最小值*/
            for(int j=i;j<arr.length;j++){
                if(arr[j].compareTo(arr[minIndex])<0){
                    minIndex=j;
                }
            }
            /*经过遍历，找到最小值之后，数组值交换*/
            swap(arr,i,minIndex);
        }
    }

    /**
     * 数组值交换
     */
    private static <E> void swap(E[] arr,int i,int j){
        /*通过中间值交换*/
        E t=arr[i];
        arr[i]=arr[j];
        arr[j]=t;
    }

    public static void main(String[] args) {
        Student[] students={new Student("Alice",98),new Student("Bobo",100),new Student("Charles",66)};
        SelectionSort.sort(students);
        for(Student student:students){
            System.out.print(student+" ");
        }
        System.out.println();
    }

}
```

## 选择排序法的复杂度分析

主要是两重循环，其他赋值swap等的操作都是常数级别的操作，而且复杂度分析中，低阶项也是需要忽略掉的。

> 分析

1. 第一重循环：执行了n轮，当第一次执行的时候，第二重循环执行了n次，当第二次执行的时候，第二重循环执行了n-1次
2. 第二重循环：$n+(n-1)+(n-2)+...+3+2+1$=$(n+1)/2$
3. $(n+1)/2*n=1/2n^2+1/2n$，复杂度因此是O($n^2$)级别

## 测速算法性能

> 注意要点
1. 需要先提供生成数组的功能，该功能生成的数据需要乱序且数据量大。
2. 算法性能测试前提，需要验证下算法功能是不是正常的，数组是不是已经排好序了，需要提供个方法验证一下。
3. 后面还会有其他排序算法，如果都去写面向过程的测试用例比较麻烦，需要封装下测试排序算法的方法。

* 学生对象类
```java
import javax.validation.constraints.NotNull;
import java.util.Objects;

/**
 * @author 学生
 */
public class Student implements Comparable<Student>{

    private String name;

    /**
     * 学生的某次考试成绩
     */
    private int score;



    public Student(String name) {
        this.name = name;
    }

    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     * equals根据需求重写，设计者根据自己需要如何判断学生相等
     * @param o
     * @return
     */
    @Override
    public boolean equals(Object o) {
        /*比较地址*/
        if (this == o){
            return true;
        }
        /*判空*/
        if (o == null){
            return false;
        }
        /*判断是不是同一个类*/
        if(getClass() != o.getClass()){
            return false;
        }
        Student student = (Student) o;
        return Objects.equals(this.name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

    /**
     * 当前的这个类和传来的这个类进行比较，如果这个类比传来的这个类小的话，就负值
     */
    @Override
    public int compareTo(@NotNull Student another) {
        return this.score-another.score;
    }

    @Override
    public String toString() {
        return String.format("Student(name: %s, score: %d)",name,score);
    }

}
```

* 排序工具类
```java
public class SortingHelper {

    private SortingHelper(){}

    /**
     * 实现判断数组是否有序的方法
     */
    public static <E extends Comparable<E>> boolean isSorted(E[] arr){
        for(int i=1;i<arr.length;i++){
            /*如果前一个元素比后一个元素大，说明数组不是有序的*/
            if(arr[i-1].compareTo(arr[i])>0){
                return Boolean.FALSE;
            }
        }
        return Boolean.TRUE;
    }

    /**
     * 排序算法测试
     */
    public static <E extends Comparable<E>> void sortTest(String sortName,E[] arr){
        long startTime=System.nanoTime();
        if(sortName.equals("SelectionSort")){
            SelectionSort.sort(arr);
        }
        long endTime=System.nanoTime();
        double time=(endTime-startTime)/1000000000.0;
        if(!SortingHelper.isSorted(arr)){
            throw new RuntimeException(sortName+" failed");
        }
        System.out.println(String.format("%s , n = %d : %f s",sortName,arr.length,time));
    }
}
```

* 数组生成器
```java
import java.util.Random;

/**
 * 数组生成器
 * @author yinaicheng
 */
public class ArrayGenerator {

    public ArrayGenerator(){
    }

    /**
     * 生成排序数组
     */
    public static Integer[] generateOrderedArray(int n){
        Integer[] arr=new Integer[n];
        for(int i=0;i<n;i++){
            arr[i]=i;
        }
        return arr;
    }

    /**
     * 生成乱序数组
     * @param n 生成数组长度
     * @param bound 随机生成的数组中最大值限制
     */
    public static Integer[] generateRandomArray(int n,int bound){
        Integer[] arr=new Integer[n];
        Random random=new Random();
        for(int i=0;i<n;i++){
            arr[i]=random.nextInt(bound);
        }
        return arr;
    }

}
```

* 选择排序工具类
```java
/**
 * 选择排序算法
 */
public class SelectionSort{

    private SelectionSort(){}

    /**
     * 需要让E这种类型实现Comparable这个接口（泛型约束）
     */
    public static <E extends Comparable<E>> void sort(E[] arr){
        /*遍历要选择排序的数组*/
        /*维持循环不变量：arr[0...i)是有序的，arr[i...n)是无序的*/
        for(int i=0;i<arr.length;i++){
            /*默认arr[i...n)最小值的索引是i*/
            int minIndex=i;
            /*遍历arr[i...n)数组，找到最小值*/
            for(int j=i;j<arr.length;j++){
                if(arr[j].compareTo(arr[minIndex])<0){
                    minIndex=j;
                }
            }
            /*经过遍历，找到最小值之后，数组值交换*/
            swap(arr,i,minIndex);
        }
    }

    /**
     * 数组值交换
     */
    private static <E> void swap(E[] arr,int i,int j){
        /*通过中间值交换*/
        E t=arr[i];
        arr[i]=arr[j];
        arr[j]=t;
    }


    public static void main(String[] args) {

        int[] dataSize = {1000, 10000, 100000};
        for (int n : dataSize) {
            Integer[] randomArr = ArrayGenerator.generateRandomArray(n, n);
            SortingHelper.sortTest("SelectionSort", randomArr);
        }
    }

}
```

* 测试结果
```log
SelectionSort , n = 1000 : 0.011699 s
SelectionSort , n = 10000 : 0.184079 s
SelectionSort , n = 100000 : 12.605487 s
```

可以看到：数据规模差十倍，性能就差100倍


