# 插入排序法

插入排序法的算法设计思想：
1. 把数组分为两部分，前面部分为有序区，后面部分为无序区，初始时有序区只有第一个元素。
2. 遍历无序区，把其中每个数不断地插入到有序区，形成更大的有序区，遍历完成时整个数组都是有序的了。

## 插入排序法循环不变量

arr[0,i)已排好序，arr[i...n)未排序，把arr[i]放到合适的位置。

## 插入排序和选择排序的区别

选择排序法和插入排序法的循环不变量基本是一致的，只是选择排序每一轮的排序结果都和后面的元素相关，插入排序每次排序结果只和遍历到的元素有关。

选择排序前几个排序好的元素肯定是整个数组中最小的元素，插入排序是把当前的元素放到合适的位置，它永远不会动索引没有遍历到的那些元素，前面排序好的结果并不是最终排好序的结果。

## 插入排序法动图

![](./photo/insertion_sort_gif.gif)

## 实现插入排序法

* Student类
```java
import javax.validation.constraints.NotNull;
import java.util.Objects;

/**
 * @author 学生
 */
public class Student implements Comparable<Student>{

    private String name;

    /**
     * 学生的某次考试成绩
     */
    private int score;



    public Student(String name) {
        this.name = name;
    }

    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     * equals根据需求重写，设计者根据自己需要如何判断学生相等
     * @param o
     * @return
     */
    @Override
    public boolean equals(Object o) {
        /*比较地址*/
        if (this == o){
            return true;
        }
        /*判空*/
        if (o == null){
            return false;
        }
        /*判断是不是同一个类*/
        if(getClass() != o.getClass()){
            return false;
        }
        Student student = (Student) o;
        return Objects.equals(this.name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

    /**
     * 当前的这个类和传来的这个类进行比较，如果这个类比传来的这个类小的话，就负值
     */
    @Override
    public int compareTo(@NotNull Student another) {
        return this.score-another.score;
    }

    @Override
    public String toString() {
        return String.format("Student(name: %s, score: %d)",name,score);
    }

}
```

* 数组排序测试工具类
```java
public class SortingHelper {

    private SortingHelper(){}

    /**
     * 实现判断数组是否有序的方法
     */
    public static <E extends Comparable<E>> boolean isSorted(E[] arr){
        for(int i=1;i<arr.length;i++){
            /*如果前一个元素比后一个元素大，说明数组不是有序的*/
            if(arr[i-1].compareTo(arr[i])>0){
                return Boolean.FALSE;
            }
        }
        return Boolean.TRUE;
    }

    /**
     * 排序算法测试
     */
    public static <E extends Comparable<E>> void sortTest(String sortName,E[] arr){
        long startTime=System.nanoTime();
        /*选择排序*/
        if(sortName.equals("SelectionSort")){
            SelectionSort.sort(arr);
        }
        /*插入排序*/
        else if(sortName.equals("InsertSort")){
            InsertSort.sort(arr);
        }
        long endTime=System.nanoTime();
        double time=(endTime-startTime)/1000000000.0;
        if(!SortingHelper.isSorted(arr)){
            throw new RuntimeException(sortName+" failed");
        }
        System.out.println(String.format("%s , n = %d : %f s",sortName,arr.length,time));
    }
}
```

* 插入排序实现
```java
/**
 * 插入排序
 */
public class InsertSort {

    private InsertSort(){
    }

    public static <E extends Comparable<E>> void sort(E[] arr){
        /*遍历数组*/
        for(int i=0;i<arr.length;i++){
            /*将arr[i]插入到合适的位置*/
            for(int j=i;j-1>=0;j--){
                /*如果j索引所在的位置的值小于前一个值，数值需要交换*/
                if(arr[j].compareTo(arr[j-1])<0){
                    swap(arr,j,j-1);
                }
                /*如果j索引所在的位置的值大于或者等于前一个值，说明已经是正确的位置，无须下次比较*/
                else{
                    break;
                }
            }
        }
    }

    /**
     * 数组值交换
     */
    private static <E> void swap(E[] arr,int i,int j){
        /*通过中间值交换*/
        E t=arr[i];
        arr[i]=arr[j];
        arr[j]=t;
    }

    public static void main(String[] args) {
        int[] dataSize={1000,10000,100000};
        for(int n:dataSize){
            Integer[] randomArr= ArrayGenerator.generateRandomArray(n,n);
            SortingHelper.sortTest("InsertSort",randomArr);
        }
    }

}
```

* 测试结果
```log
InsertSort , n = 1000 : 0.013701 s
InsertSort , n = 10000 : 0.186482 s
InsertSort , n = 100000 : 11.542177 s
```

可以看到：数据规模差十倍，性能就差100倍

## 插入排序的优化实现方法

上面提供的插入排序的实现方法，如果需要将arr[i]放置在合适的位置，需要不断地交换。
这里的设想是：每次交换都是三次操作，能不能一次操作完成，最终实现效果是记录arr[i]原先的位置和应该放置的位置，交换一次就可以了。


* 数组排序测试工具类
```java
public class SortingHelper {

    private SortingHelper(){}

    /**
     * 实现判断数组是否有序的方法
     */
    public static <E extends Comparable<E>> boolean isSorted(E[] arr){
        for(int i=1;i<arr.length;i++){
            /*如果前一个元素比后一个元素大，说明数组不是有序的*/
            if(arr[i-1].compareTo(arr[i])>0){
                return Boolean.FALSE;
            }
        }
        return Boolean.TRUE;
    }

    /**
     * 排序算法测试
     */
    public static <E extends Comparable<E>> void sortTest(String sortName,E[] arr){
        long startTime=System.nanoTime();
        /*选择排序*/
        if(sortName.equals("SelectionSort")){
            SelectionSort.sort(arr);
        }
        /*插入排序*/
        else if(sortName.equals("InsertSort")){
            InsertSort.sort(arr);
        }
        /*插入排序优化*/
        else if(sortName.equals("InsertSortOptimizate")){
            InsertSort.sortOptimizate(arr);
        }
        long endTime=System.nanoTime();
        double time=(endTime-startTime)/1000000000.0;
        if(!SortingHelper.isSorted(arr)){
            throw new RuntimeException(sortName+" failed");
        }
        System.out.println(String.format("%s , n = %d : %f s",sortName,arr.length,time));
    }
}
```


* 插入排序实现
```java
import java.util.Arrays;
/**
 * 插入排序
 */
public class InsertSort {

    private InsertSort(){
    }

    public static <E extends Comparable<E>> void sort(E[] arr){
        /*遍历数组*/
        for(int i=0;i<arr.length;i++){
            /*将arr[i]插入到合适的位置*/
            for(int j=i;j-1>=0;j--){
                /*如果j索引所在的位置的值小于前一个值，数值需要交换*/
                if(arr[j].compareTo(arr[j-1])<0){
                    swap(arr,j,j-1);
                }
                /*如果j索引所在的位置的值大于或者等于前一个值，说明已经是正确的位置，无须下次比较*/
                else{
                    break;
                }
            }
        }
    }

    /**
     * 排序优化
     */
    public static <E extends Comparable<E>> void sortOptimizate(E[] arr){
        /*遍历数组*/
        for(int i=0;i<arr.length;i++){
            /*将arr[i]插入到合适的位置*/
            E t=arr[i];
            int j;
            /*如果目标值小于j-1索引所在的位置的值，j-1数值需要平移赋值给j*/
            for(j=i;j-1>=0 && t.compareTo(arr[j-1])<0;j--){
                arr[j]=arr[j-1];
            }
            /*平移完毕后，把目标值赋予给目标位置*/
            arr[j]=t;
        }
    }

    /**
     * 数组值交换
     */
    private static <E> void swap(E[] arr,int i,int j){
        /*通过中间值交换*/
        E t=arr[i];
        arr[i]=arr[j];
        arr[j]=t;
    }

    public static void main(String[] args) {

        int[] dataSize={100000};
        for(int n:dataSize){
            Integer[] randomArr= ArrayGenerator.generateRandomArray(n,n);
            Integer[] randomArr2=Arrays.copyOf(randomArr,randomArr.length);
            SortingHelper.sortTest("InsertSort",randomArr);
            SortingHelper.sortTest("InsertSortOptimizate",randomArr2);
        }

    }
    
}
```

* 测试结果
```log
InsertSort , n = 100000 : 18.040917 s
InsertSortOptimizate , n = 100000 : 11.562508 s
```

最终优化的插入排序仍然是O($n^2$)的复杂度，所以优化方向还是重点放在复杂度级别的优化上，而不是去过度关注常数级别的优化。

## 插入排序法的重要特性

时间复杂度和选择排序法一样，仍然是O($n^2$)级别，但是插入排序有个特性，第二重循环不一定遍历到底，可能元素在比较大小的中途就停止遍历了，最极端情况下数据在未排序之前已经是有序的了，本身有序，第二重循环没必要替换赋值，插入排序的时间复杂度就变为O(n)。  
如果初始数据本身是有序的，内层循环其实只是比较一下前面那个元素，如果前一个元素就比当前要比较数值小，就说明这个元素就应该呆在当前这个位置不需要移动。  
对于选择排序来说，第二重循环必须完全遍历才能确定最小的元素，所以选择排序的复杂度一直是O($n^2$)级别。  
选择排序是稳定的O($n^2$)算法，对于插入排序来说，如果提供的数据本身是有序的，那么复杂度会变成O(n)级别。但是复杂度我们一般考虑的是最坏的情况而不是最好的情况，所以插入排序复杂度仍然是O($n^2$)级别。  
如果是近乎有序的数据，使用插入排序法是很好的选择，因为它对于有序的数组时间复杂度是O(n)级别。

* 比较插入排序与选择排序在排序数据或未排序数据情况下的时间性能

```java
import java.util.Arrays;
/**
 * 插入排序
 */
public class InsertSort {

    private InsertSort(){
    }

    public static <E extends Comparable<E>> void sort(E[] arr){
        /*遍历数组*/
        for(int i=0;i<arr.length;i++){
            /*将arr[i]插入到合适的位置*/
            for(int j=i;j-1>=0;j--){
                /*如果j索引所在的位置的值小于前一个值，数值需要交换*/
                if(arr[j].compareTo(arr[j-1])<0){
                    swap(arr,j,j-1);
                }
                /*如果j索引所在的位置的值大于或者等于前一个值，说明已经是正确的位置，无须下次比较*/
                else{
                    break;
                }
            }
        }
    }

    /**
     * 排序优化
     */
    public static <E extends Comparable<E>> void sortOptimizate(E[] arr){
        /*遍历数组*/
        for(int i=0;i<arr.length;i++){
            /*将arr[i]插入到合适的位置*/
            E t=arr[i];
            int j;
            /*如果目标值小于j-1索引所在的位置的值，j-1数值需要平移赋值给j*/
            for(j=i;j-1>=0 && t.compareTo(arr[j-1])<0;j--){
                arr[j]=arr[j-1];
            }
            /*平移完毕后，把目标值赋予给目标位置*/
            arr[j]=t;
        }
    }

    /**
     * 数组值交换
     */
    private static <E> void swap(E[] arr,int i,int j){
        /*通过中间值交换*/
        E t=arr[i];
        arr[i]=arr[j];
        arr[j]=t;
    }

    public static void main(String[] args) throws InterruptedException {

        Thread.sleep(1000);

        int[] dataSize={100000};
        for(int n:dataSize){
            System.out.println("Random Array : ");
            Integer[] randomArr= ArrayGenerator.generateRandomArray(n,n);
            Integer[] randomArr2=Arrays.copyOf(randomArr,randomArr.length);
            SortingHelper.sortTest("SelectionSort",randomArr);
            SortingHelper.sortTest("InsertSortOptimizate",randomArr2);

            System.out.println();

            System.out.println("Ordered Array : ");
            randomArr=ArrayGenerator.generateOrderedArray(n);
            randomArr2=Arrays.copyOf(randomArr,randomArr.length);

            SortingHelper.sortTest("SelectionSort",randomArr);
            SortingHelper.sortTest("InsertSortOptimizate",randomArr2);
        }

    }

}
```

* 测试结果
```log
Random Array : 
SelectionSort , n = 100000 : 11.031716 s
InsertSortOptimizate , n = 100000 : 12.894942 s

Ordered Array : 
SelectionSort , n = 100000 : 6.808563 s
InsertSortOptimizate , n = 100000 : 0.001168 s
```

