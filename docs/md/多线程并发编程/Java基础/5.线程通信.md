# 线程通信

线程通信是指多个线程在并发执行过程中，彼此之间通过某种方式进行信息交换或协作，以保证程序逻辑的正确性和执行顺序的可控性。  
在 Java 中，线程通信的方式多种多样，从最原始的共享资源，到 JDK 提供的高级协调 API，各有适用场景。

---

## 1. 文件共享

多个线程通过**读写同一个文件**来实现数据交换，这是一种最直观但效率较低的通信方式。

特点：

- 依赖操作系统 I/O
- 需要额外处理文件锁或并发写入问题
- 通常不适合高频线程通信

* 示例说明

线程 A 将数据写入文件，线程 B 轮询或监听文件内容变化后读取数据。  
在高并发场景下，磁盘 I/O 会成为性能瓶颈。

---

## 2. 网络共享

线程之间通过 **Socket、HTTP、RPC** 等网络方式进行通信。

特点：

- 线程可以位于不同进程甚至不同机器
- 通信成本高（序列化 + 网络传输）
- 常用于分布式系统，而非单 JVM 内线程通信

这种方式更偏向**进程通信**，在单 JVM 场景下使用较少。

---

## 3. 共享变量

多个线程通过访问**同一块内存中的变量**来进行通信，这是最常见的方式。

关键点：

- 可见性问题（volatile / happens-before）
- 原子性问题（synchronized / CAS）
- 有序性问题

```java
public class SharedVariableDemo {

    private static volatile boolean flag = false;

    public static void main(String[] args) {
        new Thread(() -> {
            while (!flag) {
                // 自旋等待
            }
            System.out.println("线程感知到 flag 变化");
        }).start();

        new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            flag = true;
        }).start();
    }
}
```

---

## 4. JDK 提供的线程协调 API

### 4.1 suspend 和 resume 死锁示例

`suspend()` 会挂起线程，但**不会释放锁**，极易导致死锁，已被官方废弃。

```java
public class SuspendDeadLockDemo {

    private static final Object lock = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            synchronized (lock) {
                System.out.println("线程获取锁并挂起");
                Thread.currentThread().suspend();
            }
        });

        t.start();
        Thread.sleep(1000);

        synchronized (lock) {
            System.out.println("主线程永远无法获取锁");
        }
    }
}
```

结论：**绝对不要使用 suspend / resume**。

---

### 4.2 wait / notify 代码示例

`wait()` 与 `notify()` 基于 **对象监视器（monitor）** 实现线程协作。

特点：

- 必须在 synchronized 块中使用
- wait 会释放锁
- notify 不会立即释放锁

```java
public class WaitNotifyDemo {

    private static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("线程等待");
                    lock.wait();
                    System.out.println("线程被唤醒");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();

        new Thread(() -> {
            synchronized (lock) {
                System.out.println("唤醒线程");
                lock.notify();
            }
        }).start();
    }
}
```

---

### 4.3 park 和 unpark 机制

`LockSupport.park()` 与 `unpark()` 是底层线程阻塞原语。

特点：

- 不依赖 synchronized
- 可以先 unpark 再 park
- 每个线程有一个“许可”

```java
import java.util.concurrent.locks.LockSupport;

public class ParkUnparkDemo {

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            System.out.println("线程阻塞");
            LockSupport.park();
            System.out.println("线程继续执行");
        });

        t.start();
        Thread.sleep(1000);
        LockSupport.unpark(t);
    }
}
```

---

## 5. 伪唤醒

线程在 **没有收到 notify / unpark 的情况下** 从等待状态返回，这种现象称为伪唤醒。

正确姿势：

> **永远使用 while，而不是 if 来判断条件**

```java
synchronized (lock) {
    while (!condition) {
        lock.wait();
    }
    // 条件满足后执行
}
```

---

## 6. 结语及补充

- 线程通信的本质是：**协调执行顺序 + 传递状态**
- 低级方式（共享变量）性能高但易出错
- 高级 API（Lock、Condition、BlockingQueue）更安全

在实际开发中：

- 优先使用 JDK 并发包（`java.util.concurrent`）
- 避免手写 wait/notify
- 明确 happens-before 关系

**好的线程通信设计，往往比“加锁”更重要。**
