# 线程中止

## Stop

使用Thread.stop()方法强制中止线程，并且清除监视器锁的信息，但是可能会导致线程安全问题，比如在同步代码块中，执行了一些操作之后，执行线程进入了睡眠，而此时主线程直接stop掉了睡眠的线程，此时会造成睡眠线程此前的操作生效，但是同步代码块中的后续操作并没有执行，造成了同步代码块的代码没有原子性地全部操作完或者全部没操作，从而导致线程不安全，JDK官方不建议使用。

* 线程类

```java
/**
 * 线程中止_Stop，演示
 */
public class StopThread extends Thread{

    /**
     * 初始化变量
     */
    private int i=0,j=0;

    @Override
    public void run() {
        /*增加同步锁，确保线程安全*/
        synchronized (this){
            ++i;
            try{
                /*线程休眠10秒，模拟耗时操作*/
                Thread.sleep(10000);
            }
            catch (InterruptedException e){
                e.printStackTrace();
            }
            ++j;
        }
    }

    /**
     * 打印i和j
     */
    public void print(){
        System.out.println("i="+i+" j="+j);
    }
}
```

* 测试调用

```java
/**
 * 模拟调用
 */
public class Demo {

    public static void main(String[] args) throws InterruptedException {
        StopThread thread = new StopThread();
        thread.print();
        thread.start();
        /*休眠1秒，确保i变量自增成功*/
        Thread.sleep(1000);
        /*暂停线程：错误的中止，可能会导致线程安全问题*/
        thread.stop();
        /*用来确保线程已经中止，如果中止，不会进行该循环*/
        while(thread.isAlive()){
        }
        thread.print();
    }

}
```

* 输出日志

```log
i=0 j=0
i=1 j=0
```

## interrupt

使用Thread.interrupt()方法中断线程，会抛出异常，由方法实现者来处理此情况。
睡眠线程即使被interrupt，会通过抛出异常的形式来结束掉线程，开发者可以处理异常出现后的执行逻辑，控制程序的执行，
让程序处于一个线程安全的状态，而不是像stop一样强行地中止掉线程。

> 注意事项

1. 如果目标线程在调用Object class的wait()、wait(long)或wait(long,int)方法、join()、join(long,int)或sleep(long,int)方法时被阻塞，那么interrupt会生效，该线程的中断状态将被清除，抛出InterruptedException异常。

2. 如果目标线程是被I/O或者NIO的Channel所阻塞，那么，I/O操作会被中断或者返回特殊异常值。达到中止线程的目的。

3. 如果以上条件都不满足，则会设置此线程的中断状态。

> 线程的interrupt的正确使用

1. 在线程的run()方法或者while循环中，加入Thread.interrupted()来检查中断标记，如果发现标记被置位，则执行清理操作并退出运行状态。
3. 在外部逻辑中，可以使用Thread.isInterrupted()来判断线程是否被中断，以便决定是否继续执行。
4. 如果需要在被中断的线程外部做一些处理，可以使用Thread.interrupt()来设置中断标志，然后在线程内部检查中断标志，从而执行外部逻辑。
5. 如果线程在休眠、等待或者可中断的阻塞状态，调用Thread.interrupt()方法会使线程抛出InterruptedException异常，从而提前结束阻塞状态。
6. 使用Thread.interrupt()来取消线程的执行，可以让线程在执行过程中做出正确的退出处理，从而避免数据不一致等问题发生。

* 线程类

```java
/**
 * 线程中止_Interrupt，演示
 */
public class InterruptThread extends Thread{

    /**
     * 初始化变量
     */
    private int i=0,j=0;

    @Override
    public void run() {
        /*增加同步锁，确保线程安全*/
        synchronized (this){
            ++i;
            try{
                /*线程休眠10秒，模拟耗时操作*/
                Thread.sleep(10000);
            }
            catch (InterruptedException e){
                e.printStackTrace();
            }
            ++j;
        }
    }

    /**
     * 打印i和j
     */
    public void print(){
        System.out.println("i="+i+" j="+j);
    }
}
```

* 测试调用

```java
/**
 * 模拟调用
 */
public class Demo {

    public static void main(String[] args) throws InterruptedException {
        InterruptThread thread = new InterruptThread();
        thread.print();
        thread.start();
        /*休眠1秒，确保i变量自增成功*/
        Thread.sleep(1000);
        /*暂停线程：正确的中止*/
        thread.interrupt();
        /*用来确保线程已经中止，如果中止，不会进行该循环*/
        while(thread.isAlive()){
        }
        thread.print();
    }

}
```

* 执行结果

```log
i=0 j=0
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at top.yinaicheng.demo.threadstop.InterruptThread.run(InterruptThread.java:20)
i=1 j=1
```

## 标志位

设置标志位，让线程自行停止，比如设置一个boolean型的变量，当变量的值变成false的时候，线程就自行停止。

代码逻辑中，增加一个判断，用来控制线程执行的中止。
```java
/**
 * 线程中止_标志位，演示
 */
public class Demo {

    /**
     * 标志位，默认运行
     */
    private volatile static boolean flag=true;


    /**
     * 代码逻辑中，增加一个判断，用来控制线程执行的中止
     */
    public static void main(String[] args) throws InterruptedException {
        new Thread(()->{
           /*判断是否运行*/
           while (flag){
               System.out.println("运行中");
               try {
                   Thread.sleep(1000L);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }
        }).start();
        /*三秒之后，把标志位改为false，代表程序不继续运行*/
        Thread.sleep(3000L);
        flag=false;
        System.out.println("程序结束运行");
    }

}
```

执行结果
```log
运行中
运行中
运行中
程序结束运行
```

## join

使用Thread.join()方法，让调用线程等待被调用线程结束

## ExecutorService.shutdown()

关闭线程池

## ThreadGroup.interrupt()

中断一组线程