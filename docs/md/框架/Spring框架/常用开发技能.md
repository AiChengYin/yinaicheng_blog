# 常用开发技能

## 在枚举类声明一个内部类用于获取注入实例

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import javax.annotation.PostConstruct;
public enum TestEnum {

    Test;

    public static void test() {

        System.out.println(Injector.testStr);

    }
    
    @Component
    private static class Injector{

        @Value("${test}")
        private String test;

        private static String testStr;

        @PostConstruct
        private void postConstruct(){
            Injector.testStr = test;
        }

    }

}
```

## BeanWrapperImpl

BeanWrapperImpl是Spring框架中的一个类，用于对Java对象进行包装并提供属性操作的功能。通过BeanWrapperImpl，我们可以对目标对象进行赋值。

在上面的代码中，我们首先创建了一个目标对象MyObject。然后，我们使用BeanWrapperImpl创建了一个包装器对象，并将目标对象传递给它。接着，我们通过调用setProperty方法来设置目标对象的属性值。最后，我们可以使用getProperty方法获取属性值。

需要注意的是，BeanWrapperImpl支持许多类型的属性，包括基本类型、字符串、日期、枚举、集合等等。因此，我们可以使用它来操作各种类型的Java对象。

以下是一个示例代码，演示如何使用BeanWrapperImpl对目标对象进行赋值：
```java
import org.springframework.beans.BeanWrapperImpl;
/**
 * 定义一个Person的Bean
 */
public class Person {

    private String name;

    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public static void main(String[] args) {
        /*使用BeanWrapperImpl来设置JavaBean的属性*/
        Person person = new Person();
        BeanWrapperImpl wrapper = new BeanWrapperImpl(person);
        wrapper.setPropertyValue("name", "Tom");
        wrapper.setPropertyValue("age", "20");
        System.out.println(person);
    }

}
```

## InitializingBean

可以使用 Spring 的 InitializingBean 接口来实现 Bean 的初始化操作。通过实现 InitializingBean 接口，可以在每次使用该 Spring Bean 时执行初始化操作。

具体做法是，在 Bean 类中实现 InitializingBean 接口，然后在 afterPropertiesSet() 方法中编写初始化代码。例如：

```java
@Service
public class MyService implements InitializingBean {

    private List<String> data;

    @Override
    public void afterPropertiesSet() throws Exception {
        // 初始化数据
        data = new ArrayList<>();
        data.add("foo");
        data.add("bar");
    }

    public List<String> getData() {
        return data;
    }
}
```

在每次使用 MyService Bean 的时候，Spring 框架会自动调用 afterPropertiesSet() 方法，完成 Bean 的初始化操作。

## PostConstruct

@PostConstruct 是一个在 Spring Bean 初始化完成后执行的方法注解，用于标记一个方法，表示该方法在 Bean 的依赖注入完成后立即执行，可以用来完成一些初始化操作。  
通常情况下，在 Spring Bean 的构造函数中不能保证所有的依赖注入已经完成，因此 @PostConstruct 注解提供了一个在依赖注入完成后，对 Bean 进行初始化的机会。

## @Value

这段代码使用了 Spring Framework 的注解 @Value，它的作用是将配置文件中的值注入到当前类中对应的字段中。其中 "${testValue:xxx}" 是一个占位符，表示从配置文件中读取名为 "testValue" 的值，如果找不到该值，则使用后面的默认值 "xxx"。这个占位符会在运行时被 Spring Framework 替换成配置文件中相应的值。

而 private String testValue; 则是一个类的私有字段，用于存储从配置文件中读取到的值。由于这个字段使用了 @Value 注解进行注入，所以Spring Framework会在启动应用程序时，自动读取配置文件中的 "testValue" 值，并将其注入到该字段中。

因此，可以理解为这段代码的含义是：从配置文件中读取名为 "testValue" 的值，如果找不到该值，则使用默认值 "xxx"，并将该值注入到字段 testValue 中。

## RestTemplate

RestTemplate的ParameterizedTypeReference是一个帮助我们在使用RestTemplate发送请求时处理泛型类型的工具。在使用RestTemplate时，由于HTTP请求的数据类型是不确定的，因此无法直接获取到返回结果的具体类型。ParameterizedTypeReference允许我们通过指定泛型类型来获取返回结果的具体类型。

使用ParameterizedTypeReference的步骤如下：

1. 创建ParameterizedTypeReference对象，指定泛型类型。例如，如果我们期望返回一个List<User>类型的结果，可以这样创建ParameterizedTypeReference对象：
   ParameterizedTypeReference<List<User>> typeRef = new ParameterizedTypeReference<List<User>>() {};

2. 发送请求，并使用exchange方法获取ResponseEntity对象。在exchange方法中，我们可以通过传入ParameterizedTypeReference对象来指定返回结果的具体类型。例如：
   ResponseEntity<List<User>> responseEntity = restTemplate.exchange(url, HttpMethod.GET, null, typeRef);

3. 通过ResponseEntity对象获取返回结果。由于我们在exchange方法中指定了具体的返回类型，因此可以直接通过getBody方法获取到返回结果，而不需要手动进行类型转换。例如：
   List<User> userList = responseEntity.getBody();

通过使用ParameterizedTypeReference，我们可以方便地处理泛型类型的返回结果，避免了手动进行类型转换的麻烦。这在处理复杂的返回结果时非常有用。

```java
ResponseEntity<List<InternalCloudNbsUsage>> responseEntity = restTemplate.exchange(String.format("%s?startTime=%s&endTime=%s", nvsUrl, billStartTime, billEndTime),HttpMethod.POST,new HttpEntity<>(json.toString(), headers),new ParameterizedTypeReference<List<InternalCloudNbsUsage>>() {});
```
