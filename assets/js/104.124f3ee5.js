(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{555:function(t,a,_){"use strict";_.r(a);var v=_(8),s=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"mysql锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql锁"}},[t._v("#")]),t._v(" MySQL锁")]),t._v(" "),a("h2",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),a("p",[t._v("MySQL锁是一种机制，用于控制对MySQL数据库中数据的访问并发性。锁可以防止多个会话同时修改相同的数据，从而避免数据的不一致性和冲突。MySQL提供了多种锁类型，包括共享锁、排他锁、行级锁和表级锁等，每种锁类型有不同的使用场景和特点。")]),t._v(" "),a("h2",{attrs:{id:"锁的种类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁的种类"}},[t._v("#")]),t._v(" 锁的种类")]),t._v(" "),a("blockquote",[a("p",[t._v("表锁")])]),t._v(" "),a("p",[t._v("一种用于保护表级别数据完整性的锁机制。它可以防止多个并发事务同时修改同一张表的数据，从而保证数据的一致性和准确性。"),a("br"),t._v("\nMySQL中的表锁分为两种类型：共享锁和排他锁。共享锁允许多个并发事务同时读取同一张表的数据，但阻止其他事务对该表进行写操作。排他锁则不允许其他任何事务同时对该表进行读写操作。"),a("br"),t._v("\n优点：开销小，加锁快，不会出现死锁。"),a("br"),t._v("\n缺点：锁定粒度大，发生锁粒度的概率最高，并发度最低。")]),t._v(" "),a("p",[t._v("MySQL中的表锁可以通过以下语句进行设置：")]),t._v(" "),a("ul",[a("li",[t._v("共享锁：LOCK TABLES table_name READ;")]),t._v(" "),a("li",[t._v("排他锁：LOCK TABLES table_name WRITE;")]),t._v(" "),a("li",[t._v("解锁表的语句为：UNLOCK TABLES;"),a("br"),t._v("\n需要注意的是，由于表锁会对整张表进行加锁，因此在高并发环境中，使用过度的表级锁可能会对性能产生负面影响。因此，在实际应用中应该适量使用表锁，并且结合其他锁机制进行使用。")])]),t._v(" "),a("blockquote",[a("p",[t._v("行锁")])]),t._v(" "),a("p",[t._v("MySQL行锁是一种在数据库中实现的锁机制，用于控制并发访问同一行数据的能力。行锁可防止多个并发事务同时修改同一行数据，从而保证数据的一致性和完整性。MySQL行锁有两种实现方式：共享锁和排它锁。共享锁允许多个事务同时读取同一行数据，但不允许任何事务修改该行数据。排它锁则只允许一个事务独占一行数据，其他事务无法读取或修改该行数据。"),a("br"),t._v("\nMySQL行锁的粒度可以是行级别或页面级别。在行级别锁定时，只有被锁定的行会被阻塞，而其他行和页面仍然可以被访问。在页面级别锁定时，整个页面将被锁定，因此可能会导致其他行无法访问。"),a("br"),t._v("\n要使用MySQL行锁，请使用SELECT … FOR UPDATE或SELECT … LOCK IN SHARE MODE命令，或者在事务中使用UPDATE和DELETE语句")]),t._v(" "),a("p",[t._v("优点：锁定粒度最小，发生锁冲突的概率最低，并发度也最高。"),a("br"),t._v("\n缺点：开销大，加锁慢，会出现死锁。")]),t._v(" "),a("blockquote",[a("p",[t._v("页面锁")])]),t._v(" "),a("p",[t._v("MySQL页面锁是MySQL数据库中的一种锁机制，它是一种针对表格页的锁定方式，用于保护多个事务同时访问同一张表时的数据一致性。页面锁定是MySQL中最常见的锁定方式之一，它可以锁定一整个数据页，以保护数据的完整性和一致性。页面锁定是一种共享锁和排它锁的组合，它允许多个事务同时读取同一数据页，但只允许一个事务对其进行修改。页面锁定在MySQL中的实现方式是通过InnoDB存储引擎实现的。")]),t._v(" "),a("p",[t._v("特点：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。")]),t._v(" "),a("h2",{attrs:{id:"mylsam存储引擎上的锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mylsam存储引擎上的锁"}},[t._v("#")]),t._v(" MylSAM存储引擎上的锁")]),t._v(" "),a("h2",{attrs:{id:"innodb存储引擎上的锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb存储引擎上的锁"}},[t._v("#")]),t._v(" Innodb存储引擎上的锁")]),t._v(" "),a("h2",{attrs:{id:"为什么mysql需要锁机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么mysql需要锁机制"}},[t._v("#")]),t._v(" 为什么MySQL需要锁机制")]),t._v(" "),a("p",[t._v("MySQL需要锁机制来防止并发访问数据库时出现数据不一致或冲突的问题。假设有多个会话同时对同一行数据进行修改，如果没有锁机制，可能会导致数据的不一致性，例如一个会话读取了已经被另一个会话修改的数据，或者多个会话同时修改同一行数据导致数据的冲突。通过使用锁机制，MySQL可以控制并发访问的顺序和方式，从而保证数据的一致性和正确性。")]),t._v(" "),a("h2",{attrs:{id:"mysql是如何实现锁机制的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql是如何实现锁机制的"}},[t._v("#")]),t._v(" MySQL是如何实现锁机制的")]),t._v(" "),a("p",[t._v("MySQL通过在数据行、表或者数据库级别上设置锁来实现锁机制。MySQL支持多种类型的锁，包括共享锁和排他锁，可以在读取数据时使用共享锁，在修改数据时使用排他锁。\nMySQL使用两种方式来实现锁机制：锁表和行级锁。锁表是指在整张表上设置锁，可以阻止其他用户对该表进行任何修改操作，而行级锁是指只在需要修改的行上设置锁，允许其他用户访问该表的其他行。\nMySQL还支持事务级别的锁机制，可以在事务中设置锁，以确保事务的完整性和一致性。在InnoDB存储引擎中，MySQL使用行级锁和多版本并发控制（MVCC）来实现事务级别的锁机制。")])])}),[],!1,null,null,null);a.default=s.exports}}]);